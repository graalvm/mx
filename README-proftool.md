# README #

`proftool` is a utility for capturing and examining profiles of Java
programs.  It's intended to provide machine level details about the execution to
aid with JIT performance analysis.  It currently consists of two primary components:

* a JVMTI agent for capturing all the assembly generated by the JVM.
* a parser for Linux perf output

By combining these components into a single command line, the perf
profile information can be attributed to the JIT code.

This suite must be built first to create the JVMTI agent library and the suite is normally dynamically
imported to make the commands available through mx.

### Recording a profile

There are currently 2 ways to capture profiles.  The direct way is to use the `profrecord` command
which takes a full Java command line as an argument and launches it with extra arguments
to collect the data.

```
$ mx profrecord -E fop /home/graal/oraclejdk1.8.0_291-jvmci-21.1-b03/bin/java -jar dacapo.jar fop -n 56
```

The second and simplest way is to use the `proftool` profiler with the `mx benchmark` command.  For
example, running:

```
$ mx benchmark dacapo:fop -- --profiler proftool
```

produces a uniquely named directory like `proftool_fop_2021-04-26_233847` which contains a profile of the full
benchmark run.  After capturing the profile, the perf binary output needs to be converted to text
using the `profpackage` command.

```
$ mx profpackage -E proftool_fop_2021-04-26_233847
Created /home/graal/ws/graal/compiler/proftool_fop_2021-04-26_233847.zip
```

This command additionally packs everything into a zip to make it easy to pass profiles around.
The zip can be used directly by all the `proftool` commands.

### Examining a profile.

Profile collection currently only supports Linux perf once the data is captured then the profile can
be viewed anywhere.  The primary command for examining profiles is `profhot`.  This gives a summary
of the top C functions and the top JIT methods.  The JIT methods are additionally disassembled and
annotated with the profile information.  Truncated sample output looks like this:

```
$ mx profhot -E proftool_fop_2021-04-26_233847.zip
Hot C functions:
    5.26% SpinPause
    2.72% ParMarkBitMap::mark_obj
    2.52% ParallelCompactData::add_obj
    0.58% ParCompactionManager::follow_marking_stacks
    0.47% GreyObjectsWalker_walkGreyObjects_e59a80a81022647b793f2f995d251cf18cbcbab4
    0.46% ArrayList_add_43f6399c3b46d50c69e7ebaee5e44ba3b6a870f3
    0.36% NodeClass$RawEdgesIterator_forward_a995c18efda6ed88a1c6d003330c491740373655
    0.34% __pthread_getspecific
    0.33% IsolateEnterStub_JNIFunctions_ExceptionCheck_c3880ec5388acdaaf0a33f93c718f75d394cf800_56464c7018196a101b3a4a0b8a60eff8ca309807
    0.33% EconomicMapImpl_getHashIndex_2f2f0d8ac1bbb1712528bee507fa079635b8cf3a

Hot generated code:
    2.64% sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa(int, long, int, boolean)
    1.98% java.text.DecimalFormat.subformat(java.lang.StringBuffer, java.text.Format$FieldDelegate, boolean, boolean, int, int, int, int)
    1.51% org.apache.fop.fo.FObj.addChildNode(org.apache.fop.fo.FONode)
    1.41% Interpreter
    1.16% org.apache.fop.fo.properties.PropertyMaker.findProperty(org.apache.fop.fo.PropertyList, boolean)
    1.04% java.lang.StringBuffer.append(java.lang.String)
    0.87% jshort_disjoint_arraycopy
    0.79% java.lang.StringBuffer.append(char)
    0.63% java.text.DigitList.set(boolean, java.lang.String, boolean, boolean, int, boolean)
    0.56% java.lang.StringBuffer.toString()

sun.misc.FloatingDecimal$BinaryToASCIIBuffer.dtoa(int, long, int, boolean)
0x7f5521cd8280-0x7f5521cd8f00 (samples=79, period=2538092165)
Hot region 1
       0x7f5521cd8292:  nop     word ptr [rax + rax]
       0x7f5521cd829c:  nop
       0x7f5521cd82a0:  mov     dword ptr [rsp - 0x14000], eax
 0.85% 0x7f5521cd82a7:  sub     rsp, 0x48
       0x7f5521cd82ab:  mov     qword ptr [rsp + 0x40], rbp
 0.18% 0x7f5521cd82b0:  mov     r10d, edx
 0.17% 0x7f5521cd82b3:  mov     r11, rcx
 ...
```

Every piece of generated code is disassembled and broken into hot regions where ticks are clustered.  This gives a general
overview of the hot parts of the execution.  Other options to profhot give more control on how this is printed.
